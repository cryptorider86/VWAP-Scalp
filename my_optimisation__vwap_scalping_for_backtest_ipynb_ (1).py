# -*- coding: utf-8 -*-
"""My_optimisation__VWAP_Scalping_for_backtest_ipynb_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k8dts7azObAX8YWUoY7_Po2Jsvx0Aisx
"""

# 1
!pip install numpy==1.26.4 pandas==2.2.2 pandas_ta ta backtesting

# 2
#оставить
import pandas as pd
import numpy as np
import yfinance as yf # Добавляем импорт yfinance
import re # Добавляем импорт re, так как он используется в ячейке 4
import pandas_ta as ta # Добавляем импорт pandas_ta, так как он используется в ячейке 4

# Указываем тикер для BTC-USD
ticker = "TWT-USD"
yf_ticker = yf.Ticker(ticker)

# Загружаем максимально возможные данные с интервалом 5 минут
# Обратите внимание: доступность исторических данных с интервалом 5m
# за очень длительный период через yfinance может быть ограничена.
# Также, данные yfinance могут иметь разрывы или неполные свечи.
df = yf_ticker.history(interval="5m", period="max")

# Оставляем только необходимые столбцы
df = df[['Open', 'High', 'Low', 'Close', 'Volume']].copy()

# Индекс уже является DatetimeIndex в yfinance, поэтому не нужно преобразовывать 'Gmt time' и set_index

# Удаляем строки, где High равно Low (могут быть некорректные данные)
df = df[df.High != df.Low]

# Проверяем и преобразуем столбцы в числовой тип (хотя yfinance обычно возвращает float)
for col in ['Open', 'High', 'Low', 'Close', 'Volume']:
    df[col] = pd.to_numeric(df[col], errors='coerce') # Используем coerce на всякий случай

# Удаляем строки с NaN значениями, которые могли появиться после coerce
df.dropna(inplace=True)


# Отобразим первые несколько строк и информацию о DataFrame для проверки
display(df.head())
display(df.info())

# Теперь DataFrame 'df' содержит данные по BTC в формате, близком к исходному CSV.
# Остальные ячейки, которые используют 'df', должны работать с этими данными.

"""margin = 1.0 (или 100%) означает отсутствие кредитного плеча (леверидж 1:1). Вам нужен полный капитал для открытия позиции.
margin = 0.5 (или 50%) означает кредитное плечо 2:1. Вам нужно 50% от стоимости сделки в качестве залога.
margin = 0.1 (или 10%) означает кредитное плечо 10:1. Вам нужно 10% от стоимости сделки в качестве залога.
margin = 0.01 (или 1%) означает кредитное плечо 100:1. Вам нужен всего 1% от стоимости сделки в качестве залога
"""

# 5
# @title Параметры торговой стратегии
backcandles_buy =35 # @param {type:"integer"}
backcandles_sell = 35 # @param {type:"integer"}
bb_length = 14 # @param {type:"integer"}
rsi_length = 5 # @param {type:"integer"}
rsi_buy_level = 65 # @param {type:"integer"}
rsi_sell_level = 45 # @param {type:"integer"}
atr_length = 1 # @param {type:"integer"}
bb_std = 2.0 # @param {type:"number"}
initial_cash = 10000.0 # @param {type:"number"}
position_size_percentage = 20.0 # @param {type:"number"}
margin = 0.1 # @param {type:"number"}
SLRatio = 1.0 # @param {type:"number"}
TPRatio = 4.0 # @param {type:"number"}
trade_direction = "Both" # @param ["Both", "Long Only", "Short Only"]

# 4
import pandas_ta as ta
import numpy as np
import re

# Создаем явную копию DataFrame, чтобы избежать SettingWithCopyWarning
df = df.copy()

# Преобразуем необходимые столбцы в числовой тип, обрабатывая ошибки
for col in ['Open', 'High', 'Low', 'Close', 'Volume']:
    df[col] = pd.to_numeric(df[col], errors='coerce')

# Удаляем существующие столбцы Bollinger Bands, если они есть
# Используем регулярное выражение для поиска столбцов, начинающихся с BBL_, BBM_, BBU_, BBB_, BBP_
# с последующим подчеркиванием и числовыми значениями, чтобы удалить любые предыдущие BB колонки
# независимо от их параметров length и std.
bb_col_pattern = re.compile(r'BB[LUMBP]_\d+_\d+\.?\d*')
existing_bb_cols = [col for col in df.columns if bb_col_pattern.match(col)]

if existing_bb_cols:
    df = df.drop(columns=existing_bb_cols)

# Расчет VWAP. Этот расчет не зависит от параметров BB или RSI.
df["VWAP"]=ta.vwap(df.High, df.Low, df.Close, df.Volume)

# Расчет RSI, используя параметр rsi_length из ячейки параметров.
df['RSI']=ta.rsi(df.Close, length=rsi_length)

# Расчет Bollinger Bands, используя параметры bb_length и bb_std из ячейки параметров.
my_bbands = ta.bbands(df.Close, length=bb_length, std=bb_std)
df=df.join(my_bbands)

# Код из ячейки 6
# Используем параметры backcandles_buy и backcandles_sell из ячейки параметров
# backcandles определен в ячейке параметров

df['Max_Open_Close'] = np.maximum(df['Open'], df['Close'])
df['Min_Open_Close'] = np.minimum(df['Open'], df['Close'])
df['upt'] = 1
df['dnt'] = 1
df.loc[(df['Max_Open_Close'] >= df['VWAP']), 'dnt'] = 0
df.loc[(df['Min_Open_Close'] <= df['VWAP']), 'upt'] = 0

# Используем backcandles_buy для расчета sig_upt
df['sig_upt'] = df['upt'].rolling(backcandles_buy + 1, min_periods=1).min()
# Используем backcandles_sell для расчета sig_dnt
df['sig_dnt'] = df['dnt'].rolling(backcandles_sell + 1, min_periods=1).min()

df['VWAPSignal'] = 0
df.loc[(df['sig_upt'] == 1) & (df['sig_dnt'] == 1), 'VWAPSignal'] = 3
df.loc[(df['sig_upt'] == 1) & (df['sig_dnt'] == 0), 'VWAPSignal'] = 2
df.loc[(df['sig_upt'] == 0) & (df['sig_dnt'] == 1), 'VWAPSignal'] = 1

# The following columns were temporary and can be dropped
df = df.drop(columns=['Max_Open_Close', 'Min_Open_Close', 'upt', 'dnt', 'sig_dnt', 'sig_upt'])

# Код из ячейки 14
# Обновляем функцию TotalSignal для использования rsi_buy_level и rsi_sell_level
def TotalSignal(l):
    # Проверяем условие для сигнала на покупку (2):
    # VWAPSignal должен быть равен 2 (цена выше VWAP в течение backcandles),
    # цена закрытия должна быть ниже или равна нижней полосе Боллинджера,
    # и RSI должен быть ниже или равен rsi_buy_level из параметров.
    # Исправляем название колонки BB, чтобы включить десятичную точку в std
    if (df.VWAPSignal.iloc[l] == 2
        and df.Close.iloc[l] <= df[f'BBL_{bb_length}_{bb_std}'].iloc[l]
        and df.RSI.iloc[l] <= rsi_buy_level):
            return 2
    # Проверяем условие для сигнала на продажу (1):
    # VWAPSignal должен быть равен 1 (цена ниже VWAP в течение backcandles),
    # цена закрытия должна быть выше или равна верхней полосе Боллинджера,
    # и RSI должен быть выше или равен rsi_sell_level из параметров.
    # Исправляем название колонки BB, чтобы включить десятичную точку в std
    if (df.VWAPSignal.iloc[l] == 1
        and df.Close.iloc[l] >= df[f'BBU_{bb_length}_{bb_std}'].iloc[l]
        and df.RSI.iloc[l] >= rsi_sell_level):
            return 1
    # Если ни одно из условий не выполнено, нет торгового сигнала (0).
    return 0

# Пересчитываем TotalSignal для всего DataFrame, используя обновленную функцию.
# Начинаем с start_index, учитывая зависимости индикаторов.
TotSignal = [0]*len(df)
start_index = max(backcandles_buy, backcandles_sell, bb_length, rsi_length) # Используем max из backcandles_buy и backcandles_sell
for row in range(start_index, len(df)):
    TotSignal[row] = TotalSignal(row)

df['TotalSignal'] = TotSignal

# Код из ячейки 7
#print("Столбцы DataFrame после выполнения ячейки rL84xCmYBTfA:") # Обновлено
#print(df.columns) # Обновлено
#display(df[df.TotalSignal!=0].count()) # Обновлено

# @title
import numpy as np
def pointposbreak(x):
    if x['TotalSignal']==1:
        return x['High']+1e-4
    elif x['TotalSignal']==2:
        return x['Low']-1e-4
    else:
        return np.nan

df['pointposbreak'] = df.apply(lambda row: pointposbreak(row), axis=1)

# @title
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime
st=10400
dfpl = df[st:st+350]
dfpl.reset_index(inplace=True)
fig = go.Figure(data=[go.Candlestick(x=dfpl.index,
                open=dfpl['Open'],
                high=dfpl['High'],
                low=dfpl['Low'],
                close=dfpl['Close']),
                go.Scatter(x=dfpl.index, y=dfpl.VWAP,
                           line=dict(color='blue', width=1),
                           name="VWAP"),
                go.Scatter(x=dfpl.index, y=dfpl['BBL_14_2.0'],
                           line=dict(color='green', width=1),
                           name="BBL"),
                go.Scatter(x=dfpl.index, y=dfpl['BBU_14_2.0'],
                           line=dict(color='green', width=1),
                           name="BBU")])

fig.add_scatter(x=dfpl.index, y=dfpl['pointposbreak'], mode="markers",
                marker=dict(size=10, color="MediumPurple"),
                name="Signal")
fig.show()

# @title
import pandas_ta as ta

dfpl = df.copy()
dfpl['ATR']=ta.atr(dfpl.High, dfpl.Low, dfpl.Close, length=7)

def SIGNAL():
    return dfpl.TotalSignal

# 15
from backtesting import Strategy
from backtesting import Backtest
import pandas as pd
import numpy as np

class MyStrat(Strategy):
    # Параметры стратегии. Эти значения являются значениями по умолчанию.
    # Они будут переопределены глобальными переменными перед запуском бэктеста
    # и изменены во время оптимизации.
    rsi_buy_level = 45
    rsi_sell_level = 55
    SLRatio = 1.2
    TPRatio = 2.3
    initial_cash = 10000.0 # Этот параметр используется в Backtest, не в стратегии напрямую
    position_size_percentage = 99.0 # Этот параметр используется в Backtest, не в стратегии напрямую
    margin = 0.1 # Этот параметр используется в Backtest, не в стратегии напрямую

    # Добавляем параметры, используемые в расчете сигналов, для оптимизации
    backcandles_buy = 20
    backcandles_sell = 20
    bb_length = 14 # Добавляем для полноты, используется в расчете BB
    bb_std = 2.0 # Добавляем для полноты, используется в расчете BB
    rsi_length = 14 # Добавляем для полноты, используется в расчете RSI
    atr_length = 7 # Добавляем для полноты, используется в расчете ATR
    trade_direction = "Both" # Добавляем параметр направления торговли

    # Удаляем __init__ метод, который мы добавили ранее
    # def __init__(self, data, cash, commission, margin, rsi_buy_level, rsi_sell_level, SLRatio, TPRatio):
    #     super().__init__(data, cash, commission, margin)
    #     self.rsi_buy_level = rsi_buy_level
    #     self.rsi_sell_level = rsi_sell_level
    #     self.SLRatio = SLRatio
    #     self.TPRatio = TPRatio


    def init(self):
        super().init()
        # Получаем сигнал TotalSignal.
        # Этот сигнал уже учитывает backcandles_buy и backcandles_sell,
        # а также bb_length, bb_std, rsi_length, rsi_buy_level и rsi_sell_level
        # из глобальных переменных, используемых при его расчете вне стратегии.
        # Поскольку мы добавили эти параметры в класс MyStrat, backtesting.py
        # сможет их изменять во время оптимизации и передавать в стратегию.
        # Однако, сам расчет TotalSignal по-прежнему происходит вне класса.
        # Для корректной работы оптимизации, расчет TotalSignal должен
        # использовать ЗНАЧЕНИЯ ПАРАМЕТРОВ ИЗ ЭКЗЕМПЛЯРА СТРАТЕГИИ (self.backcandles_buy и т.д.)
        # Это требует изменения ячейки 4, чтобы она принимала параметры из стратегии.
        # Пока что, SIGNAL() продолжает использовать глобальные переменные.
        # Это означает, что оптимизация backcandles_buy/sell, bb_length, bb_std, rsi_length
        # через bt.optimize() НЕ БУДЕТ влиять на расчет TotalSignal в ячейке 4.
        # Чтобы оптимизировать эти параметры, расчет индикаторов и сигналов
        # должен быть перемещен ВНУТРИ КЛАССА MyStrat.

        # Для текущей структуры, оптимизация через bt.optimize() будет
        # работать только для rsi_buy_level, rsi_sell_level, SLRatio, TPRatio,
        # initial_cash, position_size_percentage, margin, так как они используются
        # непосредственно в логике next() или в конструкторе Backtest.

        # Чтобы оптимизировать backcandles_buy/sell, bb_length, bb_std, rsi_length,
        # необходимо переместить расчет VWAPSignal и TotalSignal в метод init() или next().
        # Пока оставляем как есть, с пониманием, что оптимизация backcandles_buy/sell и т.д.
        # через bt.optimize() НЕ БУДЕТ РАБОТАТЬ с текущей структурой.

        self.signal1 = self.I(SIGNAL)


    def next(self):
        super().next()
        # Размер стоп-лосса на основе ATR.
        # Убедимся, что ATR доступен и не NaN для текущей свечи.
        if len(self.data.ATR) == 0 or np.isnan(self.data.ATR[-1]):
            return # Пропускаем, если ATR недоступен

        # Используем SLRatio из атрибута класса (который будет обновлен)
        slatr_value = self.SLRatio * self.data.ATR[-1]

        if len(self.trades) > 0:

            if len(self.data.RSI) > 0 and not np.isnan(self.data.RSI[-1]):
                # Используем rsi_sell_level и rsi_buy_level из атрибутов класса (которые будут обновлены)
                if self.trades[-1].is_long and self.data.RSI[-1] >= self.rsi_sell_level:
                    self.trades[-1].close()
                elif self.trades[-1].is_short and self.data.RSI[-1] <= self.rsi_buy_level:
                    self.trades[-1].close()

        # Логика открытия позиций на основе сигнала TotalSignal и trade_direction.
        # TotalSignal (signal1) уже учитывает все необходимые параметры.
        # Проверяем, нет ли открытых сделок перед открытием новой.
        # Доступ к последнему значению сигнала осуществляется через индексацию [-1].
        # Убедимся, что сигнал доступен и не NaN.
        if self.signal1 is not None and len(self.signal1) > 0 and not np.isnan(self.signal1[-1]):
             # Убедимся, что цена закрытия не равна 0 для расчета размера позиции.
            if len(self.data.Close) > 0 and self.data.Close[-1] != 0:
                # Рассчитываем размер позиции как долю от начального капитала, используя position_size_percentage.
                # backtesting.py size=X интерпретируется как X% от начального капитала, если не указано иное.
                # Передаем position_size_percentage / 100.0 как размер.
                # Используем position_size_percentage из атрибута класса (который будет обновлен)
                position_size_fraction = self.position_size_percentage / 100.0

                # Проверяем trade_direction перед открытием позиции
                if self.signal1[-1] == 2 and len(self.trades) == 0 and (self.trade_direction == "Both" or self.trade_direction == "Long Only"): # Сигнал на покупку
                    # Рассчитываем уровни стоп-лосса и тейк-профита.
                    sl1 = self.data.Close[-1] - slatr_value
                    # Используем TPRatio из атрибута класса (который будет обновлен)
                    tp1 = self.data.Close[-1] + self.TPRatio * self.data.ATR[-1]

                    self.buy(sl=sl1, tp=tp1, size=position_size_fraction)

                elif self.signal1[-1] == 1 and len(self.trades) == 0 and (self.trade_direction == "Both" or self.trade_direction == "Short Only"): # Сигнал на продажу
                    # Рассчитываем уровни стоп-лосса и тейк-профита.
                    sl1 = self.data.Close[-1] + slatr_value
                    # Используем TPRatio из атрибута класса (который будет обновлен)
                    tp1 = self.data.Close[-1] - self.TPRatio * self.data.ATR[-1]

                    self.sell(sl=sl1, tp=tp1, size=position_size_fraction)

# --- Добавляем код для обновления параметров стратегии из глобальных переменных ---
# Этот код гарантирует, что при стандартном запуске bt.run() используются параметры из ячейки 5
MyStrat.rsi_buy_level = rsi_buy_level
MyStrat.rsi_sell_level = rsi_sell_level
MyStrat.SLRatio = SLRatio
MyStrat.TPRatio = TPRatio
MyStrat.initial_cash = initial_cash
MyStrat.position_size_percentage = position_size_percentage
MyStrat.margin = margin
MyStrat.backcandles_buy = backcandles_buy
MyStrat.backcandles_sell = backcandles_sell
MyStrat.bb_length = bb_length
MyStrat.bb_std = bb_std
MyStrat.rsi_length = rsi_length
MyStrat.atr_length = atr_length
MyStrat.trade_direction = trade_direction # Обновляем параметр направления торговли
# --- Конец блока обновления параметров ---


# Создаем экземпляр Backtest, передавая класс стратегии
# backtesting.py автоматически свяжет глобальные переменные с атрибутами класса во время оптимизации
# Для стандартного run() мы обновляем атрибуты класса выше
bt = Backtest(dfpl, MyStrat,
              cash=initial_cash,       # Используем initial_cash из параметров
              margin=margin,           # Используем margin из параметров
              commission=0.0
             )

stat = bt.run()

display(stat)

# 17
#оставить
# Изменяем распаковку: ожидаем только один возвращаемый объект (статистику)
stat = bt.optimize(
    # Параметры для оптимизации и их диапазоны
    #backcandles_buy = range(10, 30, 2), # Включаем в оптимизацию
    #backcandles_sell = range(10, 30, 2), # Включаем в оптимизацию
    # rsi_buy_level = range(30, 70, 5), # Исключаем из оптимизации
    # rsi_sell_level = range(30, 70, 5), # Исключаем из оптимизации
    SLRatio = [round(x, 1) for x in np.arange(1.0, 3.1, 0.2)],
    TPRatio = [round(x, 1) for x in np.arange(1.0, 4.1, 0.2)],

    # Какие метрики оптимизировать
    maximize='Equity Final [$]',

    # Другие параметры оптимизации (опционально)
    # constraint=lambda param: param.backcandles_buy == param.backcandles_sell # Пример ограничения
    # method='grid' # Метод оптимизации ('grid' или 'random')
)

display(stat)
# Удаляем попытку отобразить heatmap, так как она не возвращается при оптимизации 2+ параметров
# display(heatmap)

# 16
#оставить
bt.plot(show_legend=False)